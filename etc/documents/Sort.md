# 버블정렬과 선택정렬  
[1 버블정렬](#1-버블정렬)  
[-- 1.1 버블정렬의 장단점](#11-버블정렬의-장단점)  
[-- 1.2 버블정렬을 개선할 수 있는 방법](#12-버블정렬을-개선할-수-있는-방법)  
[-- 1.3 버블정렬의 시간복잡도](#13-버블정렬의-시간복잡도)  
[2 선택정렬](#2-선택정렬)  
[-- 2.1 선택정렬의 장단점](#21-선택정렬의-장단점)  
[-- 2.2 선택정렬을 개선할 수 있는 방법](#22-선택정렬을-개선할-수-있는-방법)  
[-- 2.3 선택정렬의 시간복잡도](#23-선택정렬의-시간복잡도)  
[3 삽입정렬](#3-삽입정렬)  
[-- 3.1 삽입정렬의 장단점](#31-삽입정렬의-장단점)  
[-- 3.2 삽입정렬을 개선할 수 있는 방법](#32-삽입정렬을-개선할-수-있는-방법)  
[-- 3.3 삽입정렬의 시간복잡도](#33-삽입정렬의-시간복잡도)  

# 1 버블정렬

서로 인접한 두 원소를 비교하여 정렬하는 알고리즘이다  
즉, 바로 옆에 있는 요소를 검사하여 원하는 순서가 되도록 두 원소를 바꾸어주며 진행하게 된다    

### JavaScript로 구현한 버블정렬 예

```jsx
function bubbleSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}

const arr = [5, 3, 8, 4, 2];
console.log(bubbleSort(arr)); // [2, 3, 4, 5, 8]
```

## 1.1 버블정렬의 장단점

### 장점

버블정렬의 장점은 인접한 값만 계속해서 비교하는 방식으로 구현이 쉽다   
코드 자체가 직관적  

### 단점

인접한 두 개의 항목을 비교하는 방식으로 정렬하기 때문에 개념이 단순해서 프로그래밍하기 편하지만, 비교 작업이 너무 많아서 연산 시간이 오래 걸린다  

## 1.2 버블정렬을 개선할 수 있는 방법


## 1.3 버블정렬의 시간복잡도

버블정렬의 시간복잡도는 `O(n^2)` 이다  
이는 최악의 경우, 즉 역순으로 정렬된 경우에 발생한다  
버블정렬은 선택정렬과 마찬가지로 정렬이 거의 된 경우에도 계속해서 비교를 수행하기 때문에 시간복잡도가 높다  

# 2 선택정렬

배열을 순회하면서 요소를 선택하고 해당 요소를 마지막 요소와 바꿔는 방식으로 정렬하는 알고리즘이다  
선택한 요소는 오름차순 또는 내림차순에 따라 최대 또는 최소가 될 수 있다  

### JavaScript로 구현한 선택정렬 예

가장 작은 값을 찾아서 맨 앞으로 보내는 방식으로 정렬을 수행  

```jsx
function selectionSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      const temp = arr[i];
      arr[i] = arr[minIndex];
      arr[minIndex] = temp;
    }
  }
  return arr;
}

const arr = [5, 3, 8, 4, 2];
console.log(selectionSort(arr)); // [2, 3, 4, 5, 8]
```

## 2.1 선택정렬의 장단점

### 장점

구현이 쉽다   
정렬하려는 배열 안에서 교환하는 방식이므로 다른 메모리 공간을 필요로 하지 않는다  

### 단점

시간복잡도가 `O(n^2)`으로 비효율적입니다. 따라서 배열의 크기가 큰 경우에는 다른 정렬 알고리즘을 사용하는 것이 좋다  

불안정 정렬(Unstable Sort)입니다. 즉, 같은 값에 대해서 상대적인 위치가 변경될 수 있다  

## 2.2 선택정렬을 개선할 수 있는 방법


## 2.3 선택정렬의 시간복잡도

선택정렬의 시간복잡도는 `O(n^2)`이다  
선택정렬은 배열을 순회하면서 가장 작은 값을 찾아서 맨 앞으로 보내는 방식으로 정렬을 수행한다.  
이 때, 배열의 길이가 n일 때, n-1번의 비교를 수행하게 되므로 `O(n^2)`의 시간복잡도를 가진다

# 3 삽입정렬

정렬되지 않은 리스트에서 원소를 하나씩 선택하여 이미 정렬된 부분 리스트에 삽입해가며 정렬을 수행하는 알고리즘이다  

삽입 정렬은 아래와 같은 단계로 수행된다.   

1. 첫 번째 원소를 이미 정렬된 부분 리스트에 넣는다.  
2. 두 번째 원소부터 시작하여 정렬되지 않은 부분 리스트에서 한 원소씩 선택한다.  
3. 선택한 원소를 이미 정렬된 부분 리스트의 적절한 위치에 삽입한다.  
4. 모든 원소를 선택하고 삽입하는 과정을 반복한다.  

### JavaScript로 구현한 삽입정렬 예

`arr`은 정렬되지 않은 배열을 나타내며, `insertionSort` 함수는 삽입 정렬 알고리즘을 구현한 함수  

```jsx
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let j = i - 1;
    let temp = arr[i];
    while (j >= 0 && arr[j] > temp) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = temp;
  }
  return arr;
}

const array = [5, 3, 7, 1, 9];
console.log(insertionSort(array)); // [1, 3, 5, 7, 9]
```

## 3.1 삽입정렬의 장단점

### 장점

- 구현이 간단하고 이해하기 쉽다.
- 정렬된 배열에 대해 최선의 경우 `O(n)`의 시간 복잡도를 가지므로, 이미 정렬된 데이터에 대해서는 매우 빠르다.
- 안정적인 정렬 알고리즘이기 때문에 원본 데이터의 순서가 변경되지 않는다.

### 단점

- 최악의 경우 `O(n^2)`의 시간 복잡도를 가지므로, 배열의 크기가 큰 경우 비효율적이다.

## 3.2 삽입정렬을 개선할 수 있는 방법

## 3.3 삽입정렬의 시간복잡도

삽입 정렬의 시간 복잡도는 최선의 경우 `O(n)`, 최악의 경우 `O(n^2)`이다.  
또한, 삽입 정렬은 안정적인 정렬 알고리즘으로 알려져 있다.  