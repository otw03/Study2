# 13. 스코프
[1. 스코프란?](#1-스코프란)  
[2. 가비지 컬렉터Garbage Collector  ](#2-가비지-컬렉터garbage-collector)  
[3. 실행 컨텍스트Execution Context](#3-실행-컨텍스트execution-context)  
[-- 3.1 실행 컨텍스트란?](#31-실행-컨텍스트란)  
[-- 3.2 렉시컬 환경 Lexical Environment](#32-렉시컬-환경-lexical-environment)  
[-- -- 3.2.1 환경 레코드 Environment Record](#321-환경-레코드-environment-record)  
[-- -- 3.2.2 외부 환경 참조 Outer Lexical Environment Reference](#322-외부-환경-참조-outer-lexical-environment-reference)  
[-- -- 3.2.3 실행 단계 예시](#323-실행-단계-예시)  
[4. 호이스팅Hoisting](#4-호이스팅hoisting)  

# 1. 스코프란?

식별자가 유효한 범위  

스코프 밖에서는 스코프 내부에 있는 것에 접근 불가  

스코프 내부에서는 외부에 있는 스코프에 접근 가능  

# 2. 가비지 컬렉터Garbage Collector

- 쓸모 없어진 메모리를 관리해줌
- 참조하고 있지 않은 데이터를 관리해줌
- 주기적으로 오브젝트를 참조하고 있는지 확인한 후에  
아무도 해당 오브젝트를 가지고 있지 않다면(참조하고 있지 않다면) 삭제
- JS 엔진 백그라운드에서 돌아감
- 블럭 내부의 데이터는 블럭이 끝나면 자동으로 소멸되는 것이 아니라      가비지 컬렉터가 주기적으로 메모리를 검사해서 그 당시에 참조하고 있지 않을 때 삭제함
- 함수 내부에서도 블럭 안에서 필요한 경우에는  
필요한 곳에서(블럭 안에서) 변수를 선언하고 사용해야 한다

# 3. 실행 컨텍스트Execution Context

## 3.1 실행 컨텍스트란?

코드에 제공할 환경 정보들을 모아놓은 객체  

코드의 실행 순서와 스코프를 기억함  

## 3.2 렉시컬 환경 Lexical Environment

각각의 블록은 렉시컬 환경 Lexical Environment 라는 내부 오브젝트를 가지고 있다  

> 렉시컬 환경 Lexical Environment: 블럭마다 어떤 변수가 들어있는지, 부모는 누구인지 등 모든 정보를 가지고 있는 오브젝트
> 

### 3.2.1 환경 레코드 Environment Record

현재 블럭(어떤 데이터를 가지고 있는지)에 대한 정보

### 3.2.2 외부 환경 참조 Outer Lexical Environment Reference

부모는 누구인지(부모를 참조하는) 에 대한 정보

### 3.2.3 실행 단계 예시

전역스코프 생성

 → 실행 컨텍스트 스택에 전역스코프 렉시컬 환경이 만들어 짐  
외부 렉시컬 환경 참조 ⇒ 없음  

 → 실행 컨텍스트 스택에 블럭1 스코프 렉시컬 환경이 만들어 짐  
블럭1 외부 렉시컬 환경 참조 ⇒ 전역 렉시컬 환경  

→ 실행 컨텍스트 스택에 블럭2 스코프 렉시컬 환경이 만들어 짐  
블럭2 외부 렉시컬 환경 참조 ⇒ 블럭1  

→ 실행 컨텍스트 스택에서 추가된 순서와 반대(최근에 들어온 순서)로 삭제 됨  

```jsx
// 전역스코프
const a=1;
{   // 블럭1 스코프
		const a=2;
		{   // 블럭2 스코프
				const a=3;
		}
}
```

# 4. 호이스팅Hoisting

- 자바스크립트 엔진이 코드를 실행하기 전,   
변수, 함수, 클래스의 **`선언문`**을 끌어올리는 것(파일 제일 아래에 있어도 끌어올림)
- 코드를 실행하기 전 쭉 훑은 뒤 렉시컬 환경을 만듦
- 렉시컬 환경에 어떤 데이터가 있는지 선언을 해둠
- 변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮김

> 변수를 선언하고 초기화했을 때 **`선언 부분`**이 최상단으로 끌어올려지는 현상을 의미 (초기화 또는 대입 부분은 그대로 남아있음)
> 

```jsx
// 함수의 호이스팅은 함수의 선언문 전에 호출이 가능하게 해줌
// 함수의 선언문은 선언 이전에도 호출이 가능함
print();

function print() {
	  console.log('Hello');
}

// 변수(let, const)와 클래스는 선언만 호이스팅이 되고,
// 초기화는 안됨
// 초기화 전, 변수에 접근하면 컴파일(빌드) 에러가 발생
// console.log(hi);
let hi = 'hi';
let func1 = function () {};

// const cat = new Cat();
class Cat {}

// x 가 선언만 되어 있는 것이기 때문에 에러가 뜸
let x = 1;
{
	  console.log(x);
	  let x = 2;
}
```

